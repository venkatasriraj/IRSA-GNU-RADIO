options:
  parameters:
    author: Barry Duggan
    catch_exceptions: 'True'
    category: '[GRC Hier Blocks]'
    cmake_opt: ''
    comment: ''
    copyright: ''
    description: packet transmit
    gen_cmake: 'On'
    gen_linking: dynamic
    generate_options: qt_gui
    hier_block_src_path: '.:'
    id: pkt_xmt
    max_nouts: '0'
    output_language: python
    placement: (0,0)
    qt_qss_theme: ''
    realtime_scheduling: ''
    run: 'True'
    run_command: '{python} -u {filename}'
    run_options: prompt
    sizing_mode: fixed
    thread_safe_setters: ''
    title: pkt_xmt
    window_size: (1000,1000)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [16, 12.0]
    rotation: 0
    state: enabled

blocks:
- name: access_key
  id: variable
  parameters:
    comment: ''
    value: '''11100001010110101110100010010011'''
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [728, 108.0]
    rotation: 0
    state: enabled
- name: bpsk
  id: variable_constellation
  parameters:
    comment: ''
    const_points: '[-1-1j, -1+1j, 1+1j, 1-1j]'
    dims: '1'
    normalization: digital.constellation.AMPLITUDE_NORMALIZATION
    npwr: '1.0'
    precision: '8'
    rot_sym: '4'
    soft_dec_lut: None
    sym_map: '[0, 1, 3, 2]'
    type: bpsk
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [360, 12.0]
    rotation: 0
    state: true
- name: excess_bw
  id: variable
  parameters:
    comment: ''
    value: '0.35'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [288, 84.0]
    rotation: 0
    state: enabled
- name: hdr_format
  id: variable
  parameters:
    comment: header_format_default
    value: digital.header_format_default(access_key, 0)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [728, 12.0]
    rotation: 0
    state: enabled
- name: low_pass_filter_taps
  id: variable_low_pass_filter_taps
  parameters:
    beta: '6.76'
    comment: ''
    cutoff_freq: '20000'
    gain: '1.0'
    samp_rate: samp_rate
    value: ''
    width: '2000'
    win: window.WIN_HAMMING
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [544, 8.0]
    rotation: 0
    state: true
- name: rs_ratio
  id: variable
  parameters:
    comment: ''
    value: '1.040'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [400, 84.0]
    rotation: 0
    state: true
- name: samp_rate
  id: variable
  parameters:
    comment: ''
    value: '48000'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [192, 12.0]
    rotation: 0
    state: enabled
- name: sps
  id: variable
  parameters:
    comment: ''
    value: '4'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [288, 12.0]
    rotation: 0
    state: enabled
- name: user_id
  id: variable
  parameters:
    comment: ''
    value: '2'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1456, 124.0]
    rotation: 0
    state: enabled
- name: usrp_rate
  id: variable
  parameters:
    comment: ''
    value: '768000'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [192, 92.0]
    rotation: 0
    state: true
- name: InFile
  id: parameter
  parameters:
    alias: ''
    comment: ''
    hide: none
    label: File Name
    short_id: ''
    type: str
    value: file.txt
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [920, 12.0]
    rotation: 0
    state: true
- name: blocks_file_meta_sink_0
  id: blocks_file_meta_sink
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    detached: 'True'
    extra_dict: pmt.make_dict()
    file: iq_samples.dat
    max_seg_size: '1000000'
    rel_rate: '1'
    samp_rate: samp_rate
    type: complex
    unbuffered: 'True'
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [472, 440.0]
    rotation: 0
    state: enabled
- name: blocks_repack_bits_bb_0_0
  id: blocks_repack_bits_bb
  parameters:
    affinity: ''
    alias: ''
    align_output: 'False'
    comment: MSB
    endianness: gr.GR_MSB_FIRST
    k: '8'
    l: '1'
    len_tag_key: '"packet_len"'
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [184, 620.0]
    rotation: 0
    state: true
- name: blocks_tagged_stream_mux_0
  id: blocks_tagged_stream_mux
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    lengthtagname: packet_len
    maxoutbuf: '0'
    minoutbuf: '0'
    ninputs: '2'
    tag_preserve_head_pos: '0'
    type: byte
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1160, 208.0]
    rotation: 0
    state: true
- name: blocks_throttle2_0_0
  id: blocks_throttle2
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    ignoretag: 'True'
    limit: auto
    maximum: '0.1'
    maxoutbuf: '0'
    minoutbuf: '0'
    samples_per_second: usrp_rate
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [216, 748.0]
    rotation: 0
    state: true
- name: blocks_uchar_to_float_0_0_0_0
  id: blocks_uchar_to_float
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [432, 640.0]
    rotation: 0
    state: enabled
- name: digital_constellation_modulator_0
  id: digital_constellation_modulator
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    constellation: bpsk
    differential: 'True'
    excess_bw: excess_bw
    log: 'False'
    maxoutbuf: '0'
    minoutbuf: '0'
    samples_per_symbol: sps
    truncate: 'False'
    verbose: 'False'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [192, 340.0]
    rotation: 0
    state: enabled
- name: digital_crc32_bb_0
  id: digital_crc32_bb
  parameters:
    affinity: ''
    alias: ''
    check: 'False'
    comment: ''
    lengthtagname: '"packet_len"'
    maxoutbuf: '0'
    minoutbuf: '0'
    packed: 'True'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [600, 212.0]
    rotation: 0
    state: true
- name: digital_protocol_formatter_bb_0
  id: digital_protocol_formatter_bb
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    format: hdr_format
    len_tag_key: '"packet_len"'
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [872, 180.0]
    rotation: 0
    state: enabled
- name: epy_block_0
  id: epy_block
  parameters:
    FileName: InFile
    Pkt_len: '52'
    _source_code: "\"\"\"\nEmbedded Python Block: File Source to Tagged Stream\n\"\
      \"\"\n\nimport numpy as np\nfrom gnuradio import gr\nimport time\nimport pmt\n\
      import os.path\nimport sys\nimport base64\n\n\"\"\"\nState definitions\n   \
      \ 0   idle\n    1   send preamble\n    2   send file data\n    3   send file\
      \ name\n    4   send post filler\n\"\"\"\n\nclass blk(gr.sync_block):\n    def\
      \ __init__(self, FileName='None', Pkt_len=52, mean_interval=0.1):\n        gr.sync_block.__init__(\n\
      \            self,\n            name='EPB: File Source with Random Packet Generator',\
      \ # to Tagged Stream \n            in_sig=None,\n            out_sig=[np.uint8]\n\
      \        )\n\n        self.FileName = FileName\n        self.Pkt_len = Pkt_len\
      \ # in Bytes\n        self.state = 0      # idle state\n        self.pre_count\
      \ = 0\n        self.indx = 0\n        self._debug = 0     # debug\n        self.data\
      \ = \"\"\n        self.nitems_written = 0\n\n        # adding to the existing\
      \ code to have random packet generator with mean interval between packets\n\
      \        self.mean_interval = mean_interval # mean interval between packets\
      \ in seconds\n\n        if os.path.exists(self.FileName):\n            self.f_in\
      \ = open(self.FileName, 'rb')\n            self._eof = False\n            if\
      \ self._debug:\n                print(\"File name:\", self.FileName)\n     \
      \       self.state = 1\n        else:\n            print(self.FileName, 'does\
      \ not exist')\n            self._eof = True\n            self.state = 0\n\n\
      \        self.char_list = [\n            37,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,\n\
      \            85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,\n            85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,\n\
      \            85,85,85,93\n        ]\n        self.c_len = len(self.char_list)\n\
      \n        self.filler = [\n            37,85,85,85,35,69,79,70,\n          \
      \  85,85,85,85,85,85,85,85,\n            85,85,85,85,85,85,85,85,\n        \
      \    85,85,85,85,85,85,85,85,\n            85,85,85,85,85,85,85,85,\n      \
      \      85,85,85,85,85,85,85,85,\n            85,85,85,93\n        ]\n      \
      \  self.f_len = len(self.filler)\n\n    def work(self, input_items, output_items):\n\
      \n        while True:\n            if self.state == 0:\n                return\
      \ 0\n            else:\n                wait_time = np.random.exponential(self.mean_interval)\n\
      \                time.sleep(wait_time)\n                \n                #\
      \ if self.state == 0:\n                #     return 0\n\n                if\
      \ self.state == 1:\n\n                    buff = self.f_in.read(self.Pkt_len)\n\
      \                    b_len = len(buff)\n\n                    if b_len == 0:\n\
      \                        print('File is empty')\n                        self._eof\
      \ = False\n                        self.f_in.close()\n                     \
      \   self.state = 0\n                        self.pre_count = 0\n           \
      \             return 0\n\n                    if self._debug:\n            \
      \            print(\"state = 1\", self.pre_count)\n\n                    key1\
      \ = pmt.intern(\"packet_len\")\n                    val1 = pmt.from_long(self.c_len)\n\
      \n                    if len(output_items[0]) < self.c_len:\n              \
      \          return 0\n\n                    self.add_item_tag(\n            \
      \            0,\n                        self.nitems_written,\n            \
      \            key1,\n                        val1\n                    )\n\n\
      \                    self.indx += self.c_len\n                    self.nitems_written\
      \ += self.c_len\n\n                    i = 0\n                    while i <\
      \ self.c_len:\n                        output_items[0][i] = self.char_list[i]\n\
      \                        i += 1\n\n                    self.pre_count += 1\n\
      \                    if self.pre_count > 64:\n                        self.pre_count\
      \ = 0\n                        self.state = 2\n\n                    return\
      \ self.c_len\n\n                elif self.state == 2:\n                    buff\
      \ = self.f_in.read(self.Pkt_len)\n                    b_len = len(buff)\n\n\
      \                    if b_len == 0:\n                        print('End of file')\n\
      \                        self._eof = True\n                        self.f_in.close()\n\
      \                        self.state = 3\n                        self.pre_count\
      \ = 0\n                        return 0\n\n                    encoded = base64.b64encode(buff)\n\
      \                    e_len = len(encoded)\n\n                    if self._debug:\n\
      \                        print('b64 length =', e_len)\n\n                  \
      \  key0 = pmt.intern(\"packet_len\")\n                    val0 = pmt.from_long(e_len)\n\
      \n                    if len(output_items[0]) < e_len:\n                   \
      \     return 0\n\n                    self.add_item_tag(\n                 \
      \       0,\n                        self.nitems_written,\n                 \
      \       key0,\n                        val0\n                    )\n\n     \
      \               self.indx += e_len\n                    self.nitems_written\
      \ += e_len\n\n                    i = 0\n                    while i < e_len:\n\
      \                        output_items[0][i] = encoded[i]\n                 \
      \       i += 1\n\n                    return e_len\n\n                elif self.state\
      \ == 3:\n                    fn_len = len(self.FileName)\n\n               \
      \     key1 = pmt.intern(\"packet_len\")\n                    val1 = pmt.from_long(fn_len\
      \ + 8)\n\n                    if len(output_items[0]) < fn_len + 8:\n      \
      \                  return 0\n\n                    self.add_item_tag(\n    \
      \                    0,\n                        self.nitems_written,\n    \
      \                    key1,\n                        val1\n                 \
      \   )\n\n                    self.indx += fn_len + 8\n                    self.nitems_written\
      \ += fn_len + 8\n\n                    i = 0\n                    while i <\
      \ 8:\n                        output_items[0][i] = self.filler[i]\n        \
      \                i += 1\n\n                    j = 0\n                    while\
      \ i < (fn_len + 8):\n                        output_items[0][i] = ord(self.FileName[j])\n\
      \                        i += 1\n                        j += 1\n\n        \
      \            self.state = 4\n                    return fn_len + 8\n\n     \
      \           elif self.state == 4:\n                    if self._debug:\n   \
      \                     print(\"state = 4\", self.pre_count)\n\n             \
      \       key1 = pmt.intern(\"packet_len\")\n                    val1 = pmt.from_long(self.f_len)\n\
      \n                    if len(output_items[0]) < self.f_len:\n              \
      \          return 0\n\n                    self.add_item_tag(\n            \
      \            0,\n                        self.nitems_written,\n            \
      \            key1,\n                        val1\n                    )\n\n\
      \                    self.indx += self.f_len\n                    self.nitems_written\
      \ += self.f_len\n\n                    i = 0\n                    while i <\
      \ self.f_len:\n                        output_items[0][i] = self.filler[i]\n\
      \                        i += 1\n\n                    self.pre_count += 1\n\
      \                    if self.pre_count > 16:\n                        self.pre_count\
      \ = 0\n                        self.state = 0\n\n                    return\
      \ self.f_len\n\n                return 0\n        \n"
    affinity: ''
    alias: ''
    comment: 'Filename is specified on the command line, e.g.:

      python3 pkt_xmt.py --InFile="../gr-logo.png"'
    maxoutbuf: '0'
    mean_interval: '0.1'
    minoutbuf: '0'
  states:
    _io_cache: '(''EPB: File Source with Random Packet Generator'', ''blk'', [(''FileName'',
      "''None''"), (''Pkt_len'', ''52''), (''mean_interval'', ''0.1'')], [], [(''0'',
      ''byte'', 1)], '''', [''FileName'', ''Pkt_len'', ''mean_interval''])'
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [64, 252.0]
    rotation: 0
    state: disabled
- name: epy_block_1
  id: epy_block
  parameters:
    _source_code: "#!/usr/bin/env python\nfrom gnuradio import gr\nimport numpy as\
      \ np\nimport time\nimport struct\n\nclass iq_logger_with_timestamp(gr.sync_block):\n\
      \    def __init__(self, iq_filename=\"iq_samples.dat\", \n                 timestamp_filename=\"\
      timestamps.txt\"):\n        gr.sync_block.__init__(\n            self,\n   \
      \         name=\"iq_logger_with_timestamp\",\n            in_sig=[np.complex64],\n\
      \            out_sig=[np.complex64]\n        )\n        \n        self.iq_file\
      \ = open(iq_filename, 'wb')\n        self.timestamp_file = open(timestamp_filename,\
      \ 'w')\n        self.sample_count = 0\n        \n    def work(self, input_items,\
      \ output_items):\n        in0 = input_items[0]\n        out0 = output_items[0]\n\
      \        \n        # Get current timestamp\n        timestamp = time.time()\n\
      \        \n        # Write I-Q samples to binary file\n        self.iq_file.write(in0.tobytes())\n\
      \        \n        # Log timestamp with sample count\n        num_samples =\
      \ len(in0)\n        log_entry = f\"{timestamp},{self.sample_count},{num_samples}\\\
      n\"\n        self.timestamp_file.write(log_entry)\n        self.timestamp_file.flush()\n\
      \        \n        self.sample_count += num_samples\n        \n        # Pass\
      \ samples through\n        out0[:] = in0\n        \n        return len(out0)\n\
      \    \n    def stop(self):\n        self.iq_file.close()\n        self.timestamp_file.close()\n\
      \        return True\n\n\n# ```\n\n# Save this as `iq_logger_with_timestamp.py`\n\
      \n# ### In GRC:\n# ```\n# [Modulator] \u2192 [Custom IQ Logger] \u2192 [USRP\
      \ Sink]\n\n"
    affinity: ''
    alias: ''
    comment: ''
    iq_filename: iq
    maxoutbuf: '0'
    minoutbuf: '0'
    timestamp_filename: timestamp
  states:
    _io_cache: ('iq_logger_with_timestamp', 'iq_logger_with_timestamp', [('iq_filename',
      "'iq_samples.dat'"), ('timestamp_filename', "'timestamps.txt'")], [('0', 'complex',
      1)], [('0', 'complex', 1)], '', [])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [472, 356.0]
    rotation: 0
    state: enabled
- name: epy_block_1_0
  id: epy_block
  parameters:
    _source_code: "#!/usr/bin/env python\nfrom gnuradio import gr\nimport numpy as\
      \ np\nimport time\nimport struct\n\nclass iq_logger_with_timestamp(gr.sync_block):\n\
      \    def __init__(self, iq_filename=\"iq_samples.dat\", \n                 timestamp_filename=\"\
      timestamps.txt\"):\n        gr.sync_block.__init__(\n            self,\n   \
      \         name=\"iq_logger_with_timestamp\",\n            in_sig=[np.complex64],\n\
      \            out_sig=[np.complex64]\n        )\n        \n        self.iq_file\
      \ = open(iq_filename, 'wb')\n        self.timestamp_file = open(timestamp_filename,\
      \ 'w')\n        self.sample_count = 0\n        \n    def work(self, input_items,\
      \ output_items):\n        in0 = input_items[0]\n        out0 = output_items[0]\n\
      \        \n        # Get current timestamp\n        timestamp = time.time()\n\
      \        \n        # Write I-Q samples to binary file\n        self.iq_file.write(in0.tobytes())\n\
      \        \n        # Log timestamp with sample count\n        num_samples =\
      \ len(in0)\n        log_entry = f\"{timestamp},{self.sample_count},{num_samples}\\\
      n\"\n        self.timestamp_file.write(log_entry)\n        self.timestamp_file.flush()\n\
      \        \n        self.sample_count += num_samples\n        \n        # Pass\
      \ samples through\n        out0[:] = in0\n        \n        return len(out0)\n\
      \    \n    def stop(self):\n        self.iq_file.close()\n        self.timestamp_file.close()\n\
      \        return True\n\n\n# ```\n\n# Save this as `iq_logger_with_timestamp.py`\n\
      \n# ### In GRC:\n# ```\n# [Modulator] \u2192 [Custom IQ Logger] \u2192 [USRP\
      \ Sink]\n\n"
    affinity: ''
    alias: ''
    comment: ''
    iq_filename: iq1
    maxoutbuf: '0'
    minoutbuf: '0'
    timestamp_filename: timestamp1
  states:
    _io_cache: ('iq_logger_with_timestamp', 'iq_logger_with_timestamp', [('iq_filename',
      "'iq_samples.dat'"), ('timestamp_filename', "'timestamps.txt'")], [('0', 'complex',
      1)], [('0', 'complex', 1)], '', [])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [448, 748.0]
    rotation: 0
    state: enabled
- name: epy_block_2
  id: epy_block
  parameters:
    _source_code: "from gnuradio import gr\nimport pmt\nimport random\nimport time\n\
      import threading\n\nclass Random_Packet_Generator(gr.basic_block):\n    def\
      \ __init__(self, mean_interval=0.1, packet_size=100):\n        gr.basic_block.__init__(self,\n\
      \            name=\"random_packet_generator\",\n            in_sig=None,\n \
      \           out_sig=None)\n        self.message_port_register_out(pmt.intern('pdu_out'))\n\
      \        self.mean_interval = mean_interval\n        self.packet_size = packet_size\n\
      \        self.total_packets = 100\n        self.packet_count = 0\n        self.thread\
      \ = threading.Thread(target=self.generate_packets)\n        self.thread.daemon\
      \ = True\n        self.thread.start()\n    \n    def generate_packets(self):\n\
      \        while self.packet_count < self.total_packets:\n            # Random\
      \ wait time (uniform distribution)\n            #wait_time = random.uniform(0,\
      \ 2 * self.mean_interval)\n            wait_time = random.expovariate(1.0 /\
      \ self.mean_interval)\n            time.sleep(wait_time)\n            \n   \
      \         # Generate random packet data\n            data = [random.randint(0,\
      \ 255) for _ in range(self.packet_size)]\n            pdu = pmt.cons(pmt.PMT_NIL,\
      \ pmt.init_u8vector(len(data), data))\n            self.packet_count += 1\n\
      \            self.message_port_pub(pmt.intern('pdu_out'), pdu)\n           \
      \ print(f\"Packet transmitted after {wait_time:.3f}s wait\")"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    mean_interval: '0.035'
    minoutbuf: '0'
    packet_size: '52'
  states:
    _io_cache: ('random_packet_generator', 'Random_Packet_Generator', [('mean_interval',
      '0.1'), ('packet_size', '100')], [], [('pdu_out', 'message', 1)], '', ['mean_interval',
      'packet_size'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [0, 172.0]
    rotation: 0
    state: enabled
- name: epy_block_3_0
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\nimport pmt\nimport\
      \ time\n\nclass blk(gr.sync_block):\n\n    def __init__(self, user_id=0, samp_rate=768000,\
      \ packet_samples=100000):\n        gr.sync_block.__init__(\n            self,\n\
      \            name=\"seq_tagger\",\n            in_sig=[np.complex64],\n    \
      \        out_sig=[np.complex64]\n        )\n        self.user_id         = user_id\n\
      \        self.samp_rate       = samp_rate\n        self.packet_samples  = packet_samples\n\
      \        self.seq_num         = 0\n        self.last_tag_offset = None\n   \
      \     self.set_tag_propagation_policy(gr.TPP_ALL_TO_ALL)\n\n    def work(self,\
      \ input_items, output_items):\n        inp = input_items[0]\n        out = output_items[0]\n\
      \        out[:] = inp\n\n        # \u2500\u2500 Use pmt.intern() directly, NOT\
      \ self.pmt_intern() \u2500\u2500\n        tags = self.get_tags_in_window(\n\
      \            0, 0, len(inp),\n            pmt.intern(\"packet_len\")   # \u2190\
      \ pmt.intern not self.pmt_intern\n        )\n\n        for tag in tags:\n  \
      \          offset  = tag.offset\n\n            # Measure actual packet samples\
      \ between tags\n            if self.last_tag_offset is not None:\n         \
      \       measured = offset - self.last_tag_offset\n                print(f\"\
      [User {self.user_id}] \"\n                      f\"Measured packet_samples =\
      \ {measured}\")\n            self.last_tag_offset = offset\n\n            self.seq_num\
      \ += 1\n\n            # Add user_id tag\n            self.add_item_tag(\n  \
      \              0, offset,\n                pmt.intern(\"user_id\"),        \
      \ # \u2190 pmt.intern\n                pmt.from_long(self.user_id)    # \u2190\
      \ pmt.from_long\n            )\n\n            # Add sequence number tag\n  \
      \          self.add_item_tag(\n                0, offset,\n                pmt.intern(\"\
      seq_num\"),\n                pmt.from_long(self.seq_num)\n            )\n\n\
      \            # Add timestamp tag\n            self.add_item_tag(\n         \
      \       0, offset,\n                pmt.intern(\"tx_time\"),\n             \
      \   pmt.from_double(time.time())   # \u2190 pmt.from_double\n            )\n\
      \n            print(f\"[User {self.user_id}] Tagged PKT \"\n               \
      \   f\"seq={self.seq_num} offset={offset}\")\n\n        return len(inp)"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    packet_samples: '34079'
    samp_rate: samp_rate
    user_id: user_id
  states:
    _io_cache: ('seq_tagger', 'blk', [('user_id', '0'), ('samp_rate', '768000'), ('packet_samples',
      '100000')], [('0', 'complex', 1)], [('0', 'complex', 1)], '', ['packet_samples',
      'samp_rate', 'user_id'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1304, 380.0]
    rotation: 0
    state: enabled
- name: fft_filter_xxx_0_0_0
  id: fft_filter_xxx
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    decim: '1'
    maxoutbuf: '0'
    minoutbuf: '0'
    nthreads: '1'
    samp_delay: '0'
    taps: low_pass_filter_taps
    type: ccc
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [744, 348.0]
    rotation: 0
    state: true
- name: iq
  id: parameter
  parameters:
    alias: ''
    comment: ''
    hide: none
    label: File Name
    short_id: ''
    type: str
    value: iq_samplesTX.dat
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1048, 12.0]
    rotation: 0
    state: true
- name: iq1
  id: parameter
  parameters:
    alias: ''
    comment: ''
    hide: none
    label: File Name
    short_id: ''
    type: str
    value: iq_samples1.dat
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1456, 12.0]
    rotation: 0
    state: true
- name: mmse_resampler_xx_0
  id: mmse_resampler_xx
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    phase_shift: '0'
    resamp_ratio: 1.0/((usrp_rate/samp_rate)*rs_ratio)
    type: complex
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1024, 376.0]
    rotation: 0
    state: true
- name: pdu_pdu_to_tagged_stream_0
  id: pdu_pdu_to_tagged_stream
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    tag: packet_len
    type: byte
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [304, 184.0]
    rotation: 0
    state: enabled
- name: qtgui_time_sink_x_0
  id: qtgui_time_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: blue
    color10: dark blue
    color2: red
    color3: green
    color4: black
    color5: cyan
    color6: magenta
    color7: yellow
    color8: dark red
    color9: dark green
    comment: 1,0,1,3
    ctrlpanel: 'False'
    entags: 'True'
    grid: 'False'
    gui_hint: 1,0,1,3
    label1: ''
    label10: ''
    label2: ''
    label3: ''
    label4: ''
    label5: ''
    label6: ''
    label7: ''
    label8: ''
    label9: ''
    legend: 'True'
    marker1: '-1'
    marker10: '-1'
    marker2: '-1'
    marker3: '-1'
    marker4: '-1'
    marker5: '-1'
    marker6: '-1'
    marker7: '-1'
    marker8: '-1'
    marker9: '-1'
    name: Transmit data
    nconnections: '1'
    size: '256'
    srate: samp_rate
    stemplot: 'False'
    style1: '1'
    style10: '1'
    style2: '1'
    style3: '1'
    style4: '1'
    style5: '1'
    style6: '1'
    style7: '1'
    style8: '1'
    style9: '1'
    tr_chan: '0'
    tr_delay: '0.0'
    tr_level: '0.1'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '"packet_len"'
    type: float
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    ylabel: Amplitude
    ymax: '1.1'
    ymin: '-0.1'
    yunit: '""'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [624, 604.0]
    rotation: 0
    state: enabled
- name: timestamp
  id: parameter
  parameters:
    alias: ''
    comment: ''
    hide: none
    label: File Name
    short_id: ''
    type: str
    value: timestampsTx.txt
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1168, 12.0]
    rotation: 0
    state: true
- name: timestamp1
  id: parameter
  parameters:
    alias: ''
    comment: ''
    hide: none
    label: File Name
    short_id: ''
    type: str
    value: timestamps1.txt
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1312, 12.0]
    rotation: 0
    state: true
- name: virtual_sink_0
  id: virtual_sink
  parameters:
    alias: ''
    comment: ''
    stream_id: f_samp
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1536, 400.0]
    rotation: 0
    state: enabled
- name: virtual_sink_0_0
  id: virtual_sink
  parameters:
    alias: ''
    comment: ''
    stream_id: t1
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1432, 216.0]
    rotation: 0
    state: true
- name: virtual_source_0
  id: virtual_source
  parameters:
    alias: ''
    comment: ''
    stream_id: t1
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [8, 368.0]
    rotation: 0
    state: true
- name: virtual_source_1
  id: virtual_source
  parameters:
    alias: ''
    comment: ''
    stream_id: f_samp
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [16, 760.0]
    rotation: 0
    state: enabled
- name: zeromq_pub_sink_0
  id: zeromq_pub_sink
  parameters:
    address: tcp://127.0.0.1:49203
    affinity: ''
    alias: ''
    bind: 'True'
    comment: USRP sample rate = 768kHz
    drop_on_hwm: 'True'
    hwm: '-1'
    key: ''
    pass_tags: 'False'
    timeout: '100'
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [808, 592.0]
    rotation: 0
    state: disabled
- name: zeromq_push_sink_0
  id: zeromq_push_sink
  parameters:
    address: tcp://127.0.0.1:49212
    affinity: ''
    alias: ''
    bind: 'False'
    comment: ''
    hwm: '-1'
    pass_tags: 'False'
    timeout: '100'
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [808, 732.0]
    rotation: 0
    state: enabled

connections:
- [blocks_repack_bits_bb_0_0, '0', blocks_uchar_to_float_0_0_0_0, '0']
- [blocks_tagged_stream_mux_0, '0', virtual_sink_0_0, '0']
- [blocks_throttle2_0_0, '0', epy_block_1_0, '0']
- [blocks_uchar_to_float_0_0_0_0, '0', qtgui_time_sink_x_0, '0']
- [digital_constellation_modulator_0, '0', blocks_file_meta_sink_0, '0']
- [digital_constellation_modulator_0, '0', epy_block_1, '0']
- [digital_crc32_bb_0, '0', blocks_tagged_stream_mux_0, '1']
- [digital_crc32_bb_0, '0', digital_protocol_formatter_bb_0, '0']
- [digital_protocol_formatter_bb_0, '0', blocks_tagged_stream_mux_0, '0']
- [epy_block_0, '0', digital_crc32_bb_0, '0']
- [epy_block_1, '0', fft_filter_xxx_0_0_0, '0']
- [epy_block_1_0, '0', zeromq_pub_sink_0, '0']
- [epy_block_1_0, '0', zeromq_push_sink_0, '0']
- [epy_block_2, pdu_out, pdu_pdu_to_tagged_stream_0, pdus]
- [epy_block_3_0, '0', virtual_sink_0, '0']
- [fft_filter_xxx_0_0_0, '0', mmse_resampler_xx_0, '0']
- [mmse_resampler_xx_0, '0', epy_block_3_0, '0']
- [pdu_pdu_to_tagged_stream_0, '0', digital_crc32_bb_0, '0']
- [virtual_source_0, '0', blocks_repack_bits_bb_0_0, '0']
- [virtual_source_0, '0', digital_constellation_modulator_0, '0']
- [virtual_source_1, '0', blocks_throttle2_0_0, '0']

metadata:
  file_format: 1
  grc_version: 3.10.12.0
